أنت مهندس .NET 8 خبير في WPF و Clean Architecture.

المشروع: MarcoERP
المعمارية: Clean Architecture بطبقات صارمة
التقنيات: WPF + EF Core + SQL Server
الوثائق المرجعية: ARCHITECTURE.md + SOLUTION_STRUCTURE.md + UI_GUIDELINES.md

المطلوب – المرحلة الأولى:

1) إعادة تصميم شاشات البيع والشراء بحيث:
   - SalesInvoiceView تصبح شاشة تحرير كاملة Full Screen
   - إزالة قائمة الفواتير الجانبية منها
   - إنشاء View جديدة باسم SalesInvoiceListView لعرض الفواتير فقط
   - نفس الشيء لـ:
        - SalesReturn
        - PurchaseInvoice
        - PurchaseReturn

2) الالتزام بالآتي:
   - لا تعديل على Domain Layer
   - لا تعديل على Services
   - لا كسر للاختبارات
   - لا تعديل على Persistence
   - التعديل يكون في WpfUI فقط

3) تحديث NavigationService:
   - التنقل بين List View و Editor View
   - دعم فتح الفاتورة من القائمة
   - دعم إنشاء فاتورة جديدة

4) الحفاظ على:
   - CardPanel
   - نفس الألوان
   - نفس الخطوط
   - نفس MaterialDesign Style
   - نفس Theme

5) إعادة تنظيم Layout:
   - Header علوي
   - Body للبنود
   - Footer للإجماليات
   - مساحة أكبر للبنود

6) التأكد أن:
   - لا يوجد Code-Behind لإنشاء ViewModels
   - الالتزام بـ MVVM

النتيجة المطلوبة:
- XAML جديد منظم
- ViewModel معدل
- Navigation مضبوط
- فصل واضح بين List و Editor
- لا كسر في المنطق الحالي
أنت مهندس حلول متخصص في WPF + ERP + POS UX.

المشروع: MarcoERP
المعمارية: Clean Architecture
لا يُسمح بكسر Domain أو قواعد المحاسبة.

المطلوب – المرحلة الثانية:

1) تطوير Smart Entry Engine داخل SalesInvoiceEditorView:

- عند اختيار الصنف:
    - عرض الكمية الحالية بالمخزن
    - عرض آخر سعر بيع لهذا العميل (إن وجد)
    - عرض آخر سعر شراء
    - عرض متوسط التكلفة
    - Highlight فرق السعر

- إذا لم يوجد سعر سابق:
    - تحميل السعر الافتراضي من Product Master

- عند الدخول إلى حقل السعر:
    - SelectAll تلقائي
    - Focus تلقائي
    - Enter ينتقل للحقل التالي

- عند الضغط Enter في آخر حقل:
    - يضيف البند تلقائيًا

2) عرض الرصيد السابق للعميل:
   - Previous Balance
   - Outstanding Amount
   - تنبيه لو عليه متأخرات

3) تحسين الأداء:
   - استخدام Compiled Queries
   - عدم تحميل بيانات غير ضرورية
   - عدم كسر الاختبارات

4) إضافة Keyboard Navigation:
   - Enter → Next Field
   - F2 → تعديل بند
   - Delete → حذف بند
   - Esc → إلغاء

5) جعل عرض البنود:
   - مساحات واسعة
   - خطوط واضحة
   - الصافي Bold
   - Hover Highlight

6) الالتزام بـ:
   - MVVM فقط
   - لا Code-Behind
   - لا لمس Domain
   - لا تغيير InvoiceStatus Enum

النتيجة:
- إدخال أسرع 3 مرات
- عرض ذكي للمعلومات
- تجربة قريبة من POS احترافي
أنت مهندس معماري ERP خبير في المحاسبة المزدوجة.

المشروع: MarcoERP
المعمارية: Clean Architecture
المحاسبة: قيد مزدوج – لا يُسمح بكسر القيود

المطلوب – المرحلة الثالثة:

1) عند حفظ SalesInvoice:
   - عرض Dialog تحصيل اختياري
   - اختيار:
       - Cashbox
       - PaymentMethod
       - Amount
   - إنشاء CashReceipt تلقائي
   - ربطه بالفاتورة

2) عند حفظ PurchaseInvoice:
   - خيار دفع فوري
   - إنشاء CashPayment تلقائي

3) إضافة شاشة Quick Payment من داخل الفاتورة:
   - عرض الرصيد
   - عرض المدفوع
   - عرض المتبقي

4) منع التعديل بعد الترحيل:
   - الالتزام بـ InvoiceStatus
   - لا كسر لسياسات المحاسبة

5) التأكد من:
   - تسجيل JournalEntry صحيح
   - لا تكرار قيود
   - احترام FiscalPeriod

6) إضافة دعم:
   - استلام من عميل
   - دفع لمورد
   - مصروف
   - بدون تداخل محاسبي

7) الالتزام:
   - لا تعديل مباشر في Domain
   - لا حذف Tests
   - لا تغيير هيكل InvoiceStatus

النتيجة:
- تكامل كامل بين المبيعات والخزينة
- بدون أخطاء محاسبية
- نظام متكامل فعلي
أنت مهندس معماري خبير في .NET 8 + WPF + ERP Systems.

المشروع: MarcoERP
المعمارية: Clean Architecture صارمة
الوثائق المرجعية:
- ARCHITECTURE.md
- SOLUTION_STRUCTURE.md
- UI_GUIDELINES.md
- README.md

قبل تنفيذ أي تعديل، مطلوب:

═══════════════════════════════
المرحلة صفر: المراجعة الشاملة والتحليل
═══════════════════════════════

1) فحص كامل لحل MarcoERP:
   - Domain Layer
   - Application Layer
   - Persistence Layer
   - Infrastructure
   - WpfUI
   - NavigationService
   - ViewRegistry
   - ViewModels
   - Services
   - Enums
   - InvoiceStatus
   - PaymentMethod
   - PosService
   - Treasury Services

2) التأكد من:
   - عدم وجود كود مكرر
   - عدم وجود ميزة موجودة بالفعل
   - عدم وجود تعارض مع القيود المحاسبية
   - احترام اتجاه الاعتمادات للداخل
   - عدم كسر الاختبارات

3) مراجعة:
   - كيفية إنشاء JournalEntry عند ترحيل الفاتورة
   - كيفية تكامل الخزينة
   - كيفية تحميل الأسعار
   - كيفية إدارة حالة الفاتورة

4) لا تبدأ أي تعديل قبل إكمال التحليل المعماري.

بعد التحليل، نفّذ المراحل التالية بالتسلسل.

═══════════════════════════════
المرحلة الأولى: إعادة هيكلة شاشات البيع والشراء (UI Refactor)
═══════════════════════════════

الهدف:
- جعل SalesInvoiceView شاشة Full Screen
- إزالة قائمة الفواتير الجانبية
- إنشاء SalesInvoiceListView مستقلة
- نفس الفكرة لـ:
   - SalesReturn
   - PurchaseInvoice
   - PurchaseReturn

الشروط:
- لا تعديل في Domain
- لا تعديل في Services
- لا كسر Tests
- التعديل في WpfUI فقط
- الالتزام بـ MVVM
- لا Code-Behind لإنشاء ViewModels
- تحديث NavigationService بطريقة نظيفة

تحسينات:
- Header واضح
- Body للبنود
- Footer للإجماليات
- تصميم متناسق مع UI_GUIDELINES
- الحفاظ على نفس Theme وCardPanel

═══════════════════════════════
المرحلة الثانية: Smart Entry Engine + عرض معلومات ذكية
═══════════════════════════════

الهدف:
تطوير تجربة إدخال احترافية وسريعة.

المطلوب:

1) عند اختيار الصنف:
   - عرض الكمية الحالية بالمخزن
   - عرض آخر سعر بيع لهذا العميل (إن وجد)
   - عرض آخر سعر شراء من المورد
   - عرض متوسط التكلفة
   - Highlight فرق السعر

2) في حال عدم وجود سعر سابق:
   - تحميل السعر من Product Master

3) تحسين الإدخال:
   - Focus تلقائي
   - SelectAll في حقل السعر
   - Enter → ينتقل للحقل التالي
   - Enter في آخر حقل → إضافة البند
   - Esc → إلغاء
   - Delete → حذف بند
   - F2 → تعديل

4) عرض الرصيد السابق للعميل:
   - Outstanding Balance
   - تنبيه لو عليه متأخرات

5) تحسين الأداء:
   - استخدام Compiled Queries
   - عدم تحميل بيانات غير ضرورية
   - لا تعديل في Domain
   - لا تغيير InvoiceStatus Enum

6) الالتزام الكامل بـ MVVM.

═══════════════════════════════
المرحلة الثالثة: تكامل الخزينة الذكي
═══════════════════════════════

الهدف:
ربط الفاتورة بالخزينة دون كسر المحاسبة.

المطلوب:

1) عند حفظ SalesInvoice:
   - Dialog تحصيل اختياري
   - اختيار Cashbox
   - اختيار PaymentMethod
   - إدخال Amount
   - إنشاء CashReceipt تلقائي
   - ربطه بالفاتورة

2) عند حفظ PurchaseInvoice:
   - خيار دفع فوري
   - إنشاء CashPayment تلقائي

3) إضافة شاشة Quick Payment من داخل الفاتورة:
   - عرض الرصيد
   - عرض المدفوع
   - عرض المتبقي

4) التأكد من:
   - احترام FiscalPeriod
   - احترام JournalEntryStatus
   - عدم تكرار قيود
   - عدم كسر المحاسبة المزدوجة

5) دعم:
   - استلام من عميل
   - دفع لمورد
   - مصروف
   - دون تعارض محاسبي

═══════════════════════════════
قواعد صارمة
═══════════════════════════════

- لا إضافة كيان موجود بالفعل
- لا تكرار Services
- لا لمس Domain إلا إذا كان ضروريًا وبموافقة واضحة
- لا كسر اختبارات
- لا تغيير معماري جذري
- الالتزام بالتصميم العام
- الحفاظ على التناسق البصري
- مراجعة ملفات الحوكمة قبل أي تعديل

═══════════════════════════════
النتيجة النهائية المطلوبة
═══════════════════════════════

- شاشات Full Screen احترافية
- إدخال سريع وذكي
- تكامل خزينة كامل
- بدون كسر المحاسبة
- بدون تكرار
- بدون تضارب معماري
- مع الحفاظ على Clean Architecture
أنت مهندس معماري خبير في ERP + .NET 8 + Clean Architecture.

المشروع: MarcoERP
المعمارية: Clean Architecture صارمة
الوثائق:
- ARCHITECTURE.md
- SOLUTION_STRUCTURE.md
- UI_GUIDELINES.md

قبل التنفيذ:
قم بمراجعة شاملة لكل الطبقات للتأكد أن المزايا التالية غير موجودة مسبقًا.

══════════════════════════════════
الجزء الأول: إضافة Sales Representative (المندوب)
══════════════════════════════════

المطلوب:

1) إنشاء Entity جديدة:
   SalesRepresentative

تحتوي على:
- Id
- Code
- Name
- CommissionRate
- IsActive
- CreatedAt
- UpdatedAt

2) ربط SalesRepresentative بـ:
- Customer (مندوب افتراضي للعميل)
- SalesInvoice (مندوب خاص بالفاتورة)

3) إنشاء:
- Repository Interface
- Service
- DTOs
- Mapper
- Validator
- Migration

4) تحديث:
- SalesInvoiceService
- CustomerService

5) إضافة تقارير:
- إجمالي مبيعات حسب المندوب
- أرباح حسب المندوب
- عمولات

6) الالتزام:
- لا كسر اختبارات
- لا تغيير منطق القيود المحاسبية
- احترام Clean Architecture

══════════════════════════════════
الجزء الثاني: شاشة تعديل أسعار مجمع
══════════════════════════════════

المطلوب:

1) إنشاء PriceBulkUpdateView

تدعم:
- اختيار مجموعة أصناف
- تعديل نسبة زيادة أو نقص
- تعديل مباشر
- تحديث سعر بيع
- تحديث سعر شراء

2) الشروط:
- لا تغيير في فواتير مرحلة
- لا تأثير على قيود محاسبية
- Validation قوي
- عرض معاينة قبل الحفظ

3) إضافة:
- Service خاص بتحديث الأسعار
- سجل Audit لكل تعديل سعر

4) الالتزام:
- لا تعديل في SalesInvoiceService
- لا كسر Business Rules

══════════════════════════════════
الجزء الثالث: تطوير Shell احترافي
══════════════════════════════════

1) تطوير Sidebar:
- Collapse/Expand Animation سلسة
- Smooth Width Transition
- أيقونات فقط عند الإغلاق
- Highlight العنصر النشط
- حفظ الحالة بين الجلسات

2) إضافة Top Bar احترافي:
- Dropdown Quick Actions
- Global Search
- Theme Toggle
- Notification Icon
- User Menu

3) دعم:
- Command Palette (Ctrl+K)
- اختصارات عامة

4) الالتزام بـ UI_GUIDELINES.md
- نفس الألوان
- نفس الخطوط
- نفس CardPanel

══════════════════════════════════
الجزء الرابع: PDF Viewer داخلي + تنقل الفواتير
══════════════════════════════════

1) إضافة:
- زر عرض PDF داخل الفاتورة
- PDF Preview Dialog
- التالي / السابق
- Jump To Invoice Number

2) منع الخروج:
- Dirty State Tracking
- Confirmation Dialog
- منع الإغلاق بدون حفظ

3) التأكد:
- لا تعديل في Domain
- لا كسر InvoiceStatus

══════════════════════════════════
قواعد صارمة
══════════════════════════════════

- لا تكرار Services موجودة
- لا كسر Clean Architecture
- لا نقل منطق من Application إلى UI
- لا تعديل في JournalEntry Logic
- لا تجاوز FiscalPeriod
- لا حذف اختبارات

══════════════════════════════════
النتيجة المطلوبة
══════════════════════════════════

- إضافة مندوب متكاملة
- شاشة تعديل أسعار احترافية
- Shell عصري مع Animation
- PDF Viewer داخلي
- تنقل فواتير سريع
- بدون كسر محاسبة
- بدون تعارض معماري
أنت مهندس معماري ERP خبير في .NET 8 + WPF + Clean Architecture + Double Entry Accounting.

المشروع: MarcoERP
التقنيات: WPF + EF Core + SQL Server Express
المعمارية: Clean Architecture صارمة
الوثائق المرجعية:
- ARCHITECTURE.md
- SOLUTION_STRUCTURE.md
- UI_GUIDELINES.md
- README.md

═══════════════════════════════
المرحلة صفر: تحليل ومراجعة شاملة قبل التنفيذ
═══════════════════════════════

1) فحص كامل للطبقات:
   - Domain
   - Application
   - Persistence
   - Infrastructure
   - WpfUI
   - Tests

2) التأكد من:
   - عدم تكرار ميزة موجودة
   - عدم كسر قيود محاسبية
   - احترام اتجاه الاعتمادات
   - عدم تعارض مع InvoiceStatus
   - عدم كسر JournalEntry Logic

3) عدم البدء في أي تعديل قبل التحليل.

═══════════════════════════════
الجزء الأول: نظام تسعير احترافي متعدد المستويات
═══════════════════════════════

1) دعم:
   - سعر قطاعي
   - سعر جملة
   - سعر خاص لكل عميل
   - تسعير حسب كمية (Tier Pricing)
   - خصومات تلقائية

2) القواعد:
   - السعر الخاص للعميل له الأولوية
   - بعدها Tier Pricing
   - بعدها السعر الأساسي
   - كل عملية تسعير تُسجل في Audit

3) لا كسر للفواتير المرحلة.

4) شاشة إدارة أسعار احترافية:
   - Grid واسع
   - فلترة
   - تعديل جماعي
   - معاينة قبل الحفظ

═══════════════════════════════
الجزء الثاني: Credit Control (تحكم ائتماني محاسبي)
═══════════════════════════════

1) إضافة:
   - CreditLimit للعميل
   - DaysAllowed
   - BlockedOnOverdue

2) عند إنشاء فاتورة:
   - التحقق من الرصيد السابق
   - التحقق من الحد الائتماني
   - تنبيه
   - منع البيع أو طلب موافقة مدير

3) احترام:
   - FiscalPeriod
   - JournalEntryStatus

═══════════════════════════════
الجزء الثالث: نظام عمولات مندوبين متقدم
═══════════════════════════════

1) SalesRepresentative Entity:
   - CommissionRate
   - CommissionBasedOn (Sales / Profit)

2) احتساب العمولة:
   - عند الترحيل فقط
   - حسب صافي الربح إن تم تحديده

3) تقارير:
   - مبيعات حسب مندوب
   - أرباح حسب مندوب
   - عمولات مستحقة

═══════════════════════════════
الجزء الرابع: تحليل ربحية ذكي
═══════════════════════════════

1) عرض:
   - ربح لكل فاتورة
   - ربح لكل صنف
   - ربح لكل عميل
   - تنبيه عند البيع بخسارة

2) استخدام:
   - متوسط تكلفة
   - حركة المخزون
   - بدون كسر سياسات المخزون

═══════════════════════════════
الجزء الخامس: نظام جلسات كاشير
═══════════════════════════════

1) PosSession:
   - OpenSession
   - CloseSession
   - Cash Count
   - Difference

2) منع:
   - إنشاء فاتورة بدون جلسة مفتوحة

3) تقرير:
   - ملخص الجلسة
   - الفرق النقدي

═══════════════════════════════
الجزء السادس: جرد وتسويات مخزون
═══════════════════════════════

1) InventoryAdjustment:
   - سبب
   - كمية فعلية
   - فرق
   - إنشاء InventoryMovement تلقائي

2) تقرير فرق الجرد

═══════════════════════════════
الجزء السابع: باركود احترافي
═══════════════════════════════

1) دعم:
   - قراءة Scanner
   - توليد باركود
   - طباعة ملصقات
   - دعم وحدات متعددة

2) إدخال سريع عبر الباركود في POS

═══════════════════════════════
الجزء الثامن: Global Search + Command Palette
═══════════════════════════════

1) Ctrl+K لفتح شاشة بسرعة
2) بحث شامل عن:
   - عميل
   - صنف
   - فاتورة
   - قيد
   - سند

3) بدون تحميل كامل البيانات
   - Lazy Loading
   - Compiled Queries

═══════════════════════════════
الجزء التاسع: فحص سلامة النظام (Integrity Checker)
═══════════════════════════════

1) كشف:
   - قيود غير متوازنة
   - مخزون سلبي
   - فواتير بدون قيود
   - حركات بدون مستند

2) تقرير تفصيلي

═══════════════════════════════
الجزء العاشر: نسخ احتياطي ذكي
═══════════════════════════════

1) Auto Backup يومي
2) ضغط تلقائي
3) حذف النسخ القديمة
4) Restore آمن

═══════════════════════════════
الجزء الحادي عشر: تطوير واجهة احترافية
═══════════════════════════════

1) Sidebar:
   - Animation سلسة
   - Collapse بأيقونات فقط
   - حفظ الحالة

2) Top Bar:
   - Quick Actions
   - Notifications
   - Theme Toggle
   - User Menu

3) دعم Dark Mode احترافي

4) الالتزام التام بـ UI_GUIDELINES

═══════════════════════════════
قواعد صارمة
═══════════════════════════════

- لا كسر Clean Architecture
- لا نقل منطق من Application إلى UI
- لا كسر اختبارات
- لا تعديل في JournalEntry Logic
- لا تجاوز FiscalPeriod
- مراجعة الحوكمة قبل أي إضافة
- إضافة Migration نظيفة عند الحاجة
- تسجيل كل تغيير مهم في AuditLog

═══════════════════════════════
النتيجة النهائية
═══════════════════════════════

- ERP احترافي متكامل
- تكامل مالي كامل
- UX سريع
- نظام قابل للبيع تجاريًا
- بدون تعارض معماري
- بدون أخطاء محاسبية
أنت مهندس معماري ERP خبير في .NET 8 + Clean Architecture + WPF + Double Entry Accounting.

المشروع: MarcoERP
التقنيات: WPF + EF Core + SQL Server Express
المعمارية: Clean Architecture صارمة
الوثائق المرجعية:
- ARCHITECTURE.md
- SOLUTION_STRUCTURE.md
- UI_GUIDELINES.md
- README.md

═══════════════════════════════
المرحلة الأولى: فحص معماري شامل
═══════════════════════════════

1) افحص Structure المشروع بالكامل:
   - Domain
   - Application
   - Persistence
   - Infrastructure
   - WpfUI
   - Tests

2) تحقق من:
   - هل كل Module معزول بشكل صحيح؟
   - هل الاعتمادات تتجه للداخل فقط؟
   - هل هناك كسر لقاعدة Clean Architecture؟
   - هل يوجد منطق Business داخل UI؟
   - هل يوجد تكرار في Services؟
   - هل توجد Features مكررة بأسماء مختلفة؟

3) افحص Navigation:
   - هل الموديولات مجمعة بشكل منطقي؟
   - هل الفواتير والتقارير تحت نفس Module؟
   - هل POS داخل المبيعات؟
   - هل التقارير موزعة عشوائيًا؟
   - هل ViewRegistry منظم؟

4) افحص ViewModels:
   - هل هناك تضخم في ViewModel؟
   - هل هناك منطق زائد داخلها؟
   - هل تحتاج تقسيم؟

═══════════════════════════════
المرحلة الثانية: تنظيم الموديولات وإعادة هيكلة التنقل
═══════════════════════════════

قم بتحليل هل الهيكل الحالي مناسب لهذا التقسيم:

Modules:

- Sales
- Purchases
- Inventory
- Treasury
- Accounting
- Reports
- Settings

إذا لم يكن كذلك:
اقترح إعادة تنظيم دون كسر المعمارية.

أنشئ اقتراح:
- إعادة تنظيم مجلدات Views
- إعادة تنظيم ViewModels
- إعادة ترتيب Sidebar
- منع التداخل بين الموديولات

═══════════════════════════════
المرحلة الثالثة: مراجعة المميزات الجديدة المطلوبة
═══════════════════════════════

افحص إمكانية إضافة:

1) Customer Price List System
   - قائمة أسعار خاصة لكل عميل
   - فلترة حسب المورد
   - تعديل جماعي
   - PDF Export
   - أولوية تسعير

2) Sales Quotation System
   - عرض بيع
   - تحويل إلى فاتورة
   - تتبع حالة العرض

3) Purchase Quotation System
   - عرض شراء
   - تحويل إلى فاتورة شراء

4) Advanced Pricing Engine
   - Tier Pricing
   - Bulk Price Update
   - Margin Highlight

5) Credit Control
   - حد ائتماني
   - منع البيع عند تجاوز

6) Profit Tracking
   - ربح لكل فاتورة
   - ربح لكل صنف

افحص:
- هل هناك كيان مشابه موجود؟
- هل هناك Services تؤدي نفس الوظيفة؟
- هل يتعارض ذلك مع JournalEntry Logic؟
- هل يحتاج Migration؟
- هل هناك تأثير على الاختبارات؟

═══════════════════════════════
المرحلة الرابعة: فحص الأداء وقابلية التوسع
═══════════════════════════════

1) هل هناك:
   - Queries ثقيلة؟
   - Lazy Loading غير مضبوط؟
   - تحميل بيانات غير ضرورية؟

2) هل المشروع قابل للتوسع مستقبلاً؟

3) هل هناك مكان محتمل لبهوقة مع زيادة المميزات؟

═══════════════════════════════
المرحلة الخامسة: اقتراحات تطوير إضافية
═══════════════════════════════

قم بتحليل النظام واقتراح:

- مميزات ناقصة تجاريًا
- تحسينات UX
- تحسينات محاسبية
- تحسينات أمنية
- تحسينات في التقارير
- تحسينات في التكامل بين الموديولات

إذا وجدت ضعفًا:
اقترح حلًا معماريًا وليس مجرد حل شكلي.

═══════════════════════════════
قواعد صارمة
═══════════════════════════════

- لا تقترح إعادة كتابة كاملة
- لا تقترح كسر Clean Architecture
- لا تنقل منطق Business إلى UI
- لا تقترح حذف اختبارات
- لا تقترح Features مكررة

═══════════════════════════════
النتيجة المطلوبة
═══════════════════════════════

تقرير تحليلي يحتوي على:

1) نقاط القوة
2) نقاط الضعف
3) أماكن البهوقة
4) اقتراحات إعادة التنظيم
5) خطة تحسين تدريجية
6) تحذيرات معمارية
7) قائمة Features مستقبلية
